{
  "name": "XLPostcards - Postcard Back Generator",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "generate-postcard-back",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook - Generate Postcard Back",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        240,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Validate input and calculate layout\nconst input = $input.all()[0].json;\n\n// Validation\nif (!input.message || typeof input.message !== 'string') {\n  throw new Error('Message is required and must be a string');\n}\n\nif (!input.recipientInfo || !input.recipientInfo.to) {\n  throw new Error('Recipient information is required');\n}\n\nif (!input.postcardSize || !['regular', 'xl'].includes(input.postcardSize)) {\n  throw new Error('Invalid postcard size');\n}\n\n// Base dimensions for layout calculations (matching printSpecs.ts)\nconst baseDimensions = {\n  regular: { width: 1800, height: 1200 },\n  xl: { width: 2754, height: 1872 }\n};\n\nconst base = baseDimensions[input.postcardSize];\nconst dimensions = input.dimensions || base;\nconst scaleX = dimensions.width / base.width;\nconst scaleY = dimensions.height / base.height;\n\n// Layout calculations (matching PostcardBackLayout.tsx exactly)\nlet layout;\nif (input.postcardSize === 'regular') {\n  // 4x6 layout\n  layout = {\n    messageLeft: 72 * scaleX,\n    messageTop: 72 * scaleY,\n    messageWidth: 900 * scaleX,\n    messageHeight: (base.height - 144) * scaleY,\n    addressRight: 72 * scaleX,\n    addressBottom: 172 * scaleY,\n    addressWidth: 600 * scaleX,\n    addressHeight: 300 * scaleY,\n    messageFontSize: 36 * Math.min(scaleX, scaleY),\n    addressFontSize: 32 * Math.min(scaleX, scaleY),\n  };\n} else {\n  // 6x9 layout\n  layout = {\n    messageLeft: 108 * scaleX,\n    messageTop: 108 * scaleY,\n    messageWidth: 1060 * scaleX,\n    messageHeight: (base.height - 216) * scaleY,\n    addressRight: 108 * scaleX,\n    addressBottom: 228 * scaleY,\n    addressWidth: 700 * scaleX,\n    addressHeight: 300 * scaleY,\n    messageFontSize: 56 * Math.min(scaleX, scaleY),\n    addressFontSize: 48 * Math.min(scaleX, scaleY),\n  };\n}\n\n// Calculate address position\nconst addressX = dimensions.width - layout.addressRight - layout.addressWidth;\nconst addressY = dimensions.height - layout.addressBottom - layout.addressHeight;\n\nconsole.log(`[POSTCARD_BACK] Processing ${input.postcardSize} postcard: ${dimensions.width}x${dimensions.height}`);\nconsole.log(`[POSTCARD_BACK] Message area: ${layout.messageWidth}x${layout.messageHeight} at (${layout.messageLeft}, ${layout.messageTop})`);\nconsole.log(`[POSTCARD_BACK] Address area: ${layout.addressWidth}x${layout.addressHeight} at (${addressX}, ${addressY})`);\nconsole.log(`[POSTCARD_BACK] Font sizes: message=${layout.messageFontSize}, address=${layout.addressFontSize}`);\n\nreturn [{\n  json: {\n    ...input,\n    dimensions,\n    layout: {\n      ...layout,\n      addressX,\n      addressY\n    },\n    transactionId: input.transactionId || `postcard-${Date.now()}`\n  }\n}];"
      },
      "id": "validate-input",
      "name": "Validate Input & Calculate Layout",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        300
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "# Import required libraries\nfrom PIL import Image, ImageDraw, ImageFont\nimport io\nimport base64\nimport textwrap\nimport re\n\ndef generate_postcard_back():\n    try:\n        config = items[0]['json']\n        dimensions = config['dimensions']\n        layout = config['layout']\n        message = config['message']\n        recipient = config['recipientInfo']\n        postcard_size = config['postcardSize']\n        transaction_id = config['transactionId']\n        \n        print(f\"[POSTCARD_BACK] Creating {dimensions['width']}x{dimensions['height']} postcard back\")\n        print(f\"[POSTCARD_BACK] Transaction ID: {transaction_id}\")\n        print(f\"[POSTCARD_BACK] Message: {message[:50]}...\")\n        \n        # Create white canvas\n        canvas = Image.new('RGB', (dimensions['width'], dimensions['height']), 'white')\n        draw = ImageDraw.Draw(canvas)\n        print(f\"[POSTCARD_BACK] Created white canvas: {canvas.size}\")\n        \n        # Font loading with fallbacks\n        def load_font(size, bold=False):\n            font_paths = [\n                # macOS fonts\n                f\"/System/Library/Fonts/Arial{'Bold' if bold else ''}.ttf\",\n                f\"/System/Library/Fonts/Helvetica{'Bold' if bold else ''}.ttc\",\n                # Linux fonts\n                f\"/usr/share/fonts/truetype/liberation/Liberation{'Bold' if bold else 'Sans'}.ttf\",\n                f\"/usr/share/fonts/truetype/dejavu/DejaVu{'Bold' if bold else 'Sans'}.ttf\",\n                # Windows fonts (if available)\n                f\"C:/Windows/Fonts/arial{'bd' if bold else ''}.ttf\"\n            ]\n            \n            for font_path in font_paths:\n                try:\n                    return ImageFont.truetype(font_path, int(size))\n                except (OSError, IOError):\n                    continue\n            \n            # Final fallback to default font\n            print(f\"[POSTCARD_BACK] Could not load custom font, using default\")\n            return ImageFont.load_default()\n        \n        # Load fonts\n        message_font = load_font(layout['messageFontSize'])\n        address_font = load_font(layout['addressFontSize'])\n        address_font_bold = load_font(layout['addressFontSize'], bold=True)\n        \n        print(f\"[POSTCARD_BACK] Fonts loaded: message={layout['messageFontSize']}px, address={layout['addressFontSize']}px\")\n        \n        # Word wrap message text\n        # Calculate approximate characters per line based on font size and area width\n        avg_char_width = layout['messageFontSize'] * 0.6  # Approximate character width\n        max_chars_per_line = int(layout['messageWidth'] / avg_char_width)\n        \n        # Ensure minimum and maximum line lengths\n        max_chars_per_line = max(20, min(max_chars_per_line, 80))\n        \n        print(f\"[POSTCARD_BACK] Text wrapping: {max_chars_per_line} chars per line\")\n        \n        # Wrap the text\n        wrapped_lines = textwrap.fill(message, width=max_chars_per_line).split('\\n')\n        \n        # Calculate line height\n        line_height = layout['messageFontSize'] * 1.3\n        \n        # Draw message text line by line\n        current_y = layout['messageTop']\n        for i, line in enumerate(wrapped_lines):\n            if current_y + line_height > layout['messageTop'] + layout['messageHeight']:\n                print(f\"[POSTCARD_BACK] Message truncated at line {i} due to height limit\")\n                break\n            \n            draw.text(\n                (layout['messageLeft'], current_y),\n                line,\n                font=message_font,\n                fill='black'\n            )\n            current_y += line_height\n        \n        print(f\"[POSTCARD_BACK] Drew {len(wrapped_lines)} lines of message text\")\n        \n        # Draw address section\n        address_line_height = layout['addressFontSize'] * 1.3\n        current_y = layout['addressY']\n        \n        # Name (bold)\n        draw.text(\n            (layout['addressX'], current_y), \n            recipient['to'], \n            font=address_font_bold, \n            fill='black'\n        )\n        current_y += address_line_height\n        print(f\"[POSTCARD_BACK] Drew recipient name: {recipient['to']}\")\n        \n        # Address line 1\n        draw.text(\n            (layout['addressX'], current_y), \n            recipient['addressLine1'], \n            font=address_font, \n            fill='black'\n        )\n        current_y += address_line_height\n        print(f\"[POSTCARD_BACK] Drew address line 1: {recipient['addressLine1']}\")\n        \n        # Address line 2 (if exists)\n        if recipient.get('addressLine2') and recipient['addressLine2'].strip():\n            draw.text(\n                (layout['addressX'], current_y), \n                recipient['addressLine2'], \n                font=address_font, \n                fill='black'\n            )\n            current_y += address_line_height\n            print(f\"[POSTCARD_BACK] Drew address line 2: {recipient['addressLine2']}\")\n        \n        # City, State ZIP (with small gap)\n        current_y += address_line_height * 0.3\n        city_state_zip = f\"{recipient['city']}, {recipient['state']} {recipient['zipcode']}\"\n        draw.text(\n            (layout['addressX'], current_y), \n            city_state_zip, \n            font=address_font, \n            fill='black'\n        )\n        print(f\"[POSTCARD_BACK] Drew city/state/zip: {city_state_zip}\")\n        \n        # Convert to base64 PNG\n        buffer = io.BytesIO()\n        canvas.save(buffer, format='PNG', quality=100, optimize=True)\n        buffer.seek(0)\n        \n        img_base64 = base64.b64encode(buffer.getvalue()).decode('utf-8')\n        file_size = len(buffer.getvalue())\n        \n        print(f\"[POSTCARD_BACK] Generated postcard back: {file_size} bytes\")\n        print(f\"[POSTCARD_BACK] Canvas size: {canvas.size[0]}x{canvas.size[1]}\")\n        \n        return [{\n            'json': {\n                'success': True,\n                'postcardSize': postcard_size,\n                'dimensions': dimensions,\n                'transactionId': transaction_id,\n                'fileSize': file_size,\n                'messageLines': len(wrapped_lines)\n            },\n            'binary': {\n                'postcard_back': {\n                    'data': img_base64,\n                    'mimeType': 'image/png',\n                    'fileName': f\"postcard-back-{transaction_id}.png\"\n                }\n            }\n        }]\n        \n    except Exception as e:\n        error_msg = str(e)\n        print(f\"[POSTCARD_BACK] Fatal error: {error_msg}\")\n        return [{\n            'json': {\n                'success': False,\n                'error': error_msg,\n                'postcardSize': config.get('postcardSize', 'unknown') if 'config' in locals() else 'unknown',\n                'transactionId': config.get('transactionId', 'unknown') if 'config' in locals() else 'unknown'\n            }\n        }]\n\n# Execute the postcard back generation\nresult = generate_postcard_back()\nreturn result"
      },
      "id": "generate-postcard-back",
      "name": "Generate Postcard Back Image",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        680,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "success-condition",
              "leftValue": "={{ $json.success }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-success",
      "name": "Check Success",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        900,
        300
      ]
    },
    {
      "parameters": {
        "url": "https://api.cloudinary.com/v1_1/YOUR_CLOUD_NAME/image/upload",
        "sendBinaryData": true,
        "binaryPropertyName": "postcard_back",
        "options": {
          "bodyContentType": "multipart-form-data",
          "formData": {
            "parameters": [
              {
                "name": "public_id",
                "value": "={{ $json.transactionId }}-postcard-back"
              },
              {
                "name": "upload_preset",
                "value": "YOUR_UPLOAD_PRESET"
              },
              {
                "name": "folder",
                "value": "xlpostcards/backs"
              },
              {
                "name": "quality",
                "value": "100"
              },
              {
                "name": "format",
                "value": "png"
              }
            ]
          },
          "timeout": 30000
        }
      },
      "id": "upload-to-cloudinary",
      "name": "Upload to Cloudinary",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1120,
        200
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"success\": true,\n  \"postcard_back_url\": \"{{ $json.secure_url }}\",\n  \"public_id\": \"{{ $json.public_id }}\",\n  \"postcardSize\": \"{{ $('Generate Postcard Back Image').item.json.postcardSize }}\",\n  \"dimensions\": {{ $('Generate Postcard Back Image').item.json.dimensions }},\n  \"transactionId\": \"{{ $('Generate Postcard Back Image').item.json.transactionId }}\",\n  \"fileSize\": {{ $('Generate Postcard Back Image').item.json.fileSize }},\n  \"messageLines\": {{ $('Generate Postcard Back Image').item.json.messageLines }},\n  \"cloudinary_url\": \"{{ $json.url }}\",\n  \"generated_at\": \"{{ $now }}\"\n}",
        "options": {}
      },
      "id": "success-response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1340,
        200
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseCode": 400,
        "responseBody": "{\n  \"success\": false,\n  \"error\": \"{{ $json.error || 'Failed to generate postcard back' }}\",\n  \"postcardSize\": \"{{ $json.postcardSize || 'unknown' }}\",\n  \"transactionId\": \"{{ $json.transactionId || 'unknown' }}\",\n  \"timestamp\": \"{{ $now }}\"\n}",
        "options": {}
      },
      "id": "error-response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1120,
        400
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook - Generate Postcard Back": {
      "main": [
        [
          {
            "node": "Validate Input & Calculate Layout",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input & Calculate Layout": {
      "main": [
        [
          {
            "node": "Generate Postcard Back Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Postcard Back Image": {
      "main": [
        [
          {
            "node": "Check Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Success": {
      "main": [
        [
          {
            "node": "Upload to Cloudinary",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload to Cloudinary": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "your-instance-id"
  },
  "id": "xlpostcards-postcard-back-workflow",
  "tags": [
    {
      "createdAt": "2024-01-01T00:00:00.000Z",
      "updatedAt": "2024-01-01T00:00:00.000Z",
      "id": "xlpostcards",
      "name": "XLPostcards"
    }
  ]
}