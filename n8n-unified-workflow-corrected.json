{
  "name": "XLPostcards - Unified Postcard Generator",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "generate-postcard-back-unified",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook - Unified Generate Postcard Back",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -880,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Validate input and calculate layout with LARGE fonts\nconst input = $input.all()[0].json.body || $input.all()[0].json;\n\n// Validation\nif (!input.message || typeof input.message !== 'string') {\n  throw new Error('Message is required and must be a string');\n}\n\nif (!input.recipientInfo || !input.recipientInfo.to) {\n  throw new Error('Recipient information is required');\n}\n\nif (!input.postcardSize || !['regular', 'xl'].includes(input.postcardSize)) {\n  throw new Error('Invalid postcard size');\n}\n\n// Detect test mode from request\nconst isTestMode = input.testMode === true || input.variant === 'development' || input.isTest === true;\n\n// Base dimensions for layout calculations (matching printSpecs.ts)\nconst baseDimensions = {\n  regular: { width: 1800, height: 1200 },\n  xl: { width: 2754, height: 1872 }\n};\n\nconst base = baseDimensions[input.postcardSize];\nconst dimensions = input.dimensions || base;\nconst scaleX = dimensions.width / base.width;\nconst scaleY = dimensions.height / base.height;\n\n// MUCH LARGER Layout calculations - FIXED FONT SIZES\nlet layout;\nif (input.postcardSize === 'regular') {\n  // 4x6 layout - SIGNIFICANTLY LARGER FONTS\n  layout = {\n    messageLeft: 72 * scaleX,\n    messageTop: 72 * scaleY,\n    messageWidth: 900 * scaleX,\n    messageHeight: (base.height - 144) * scaleY,\n    addressRight: 72 * scaleX,\n    addressBottom: 172 * scaleY,\n    addressWidth: 600 * scaleX,\n    addressHeight: 300 * scaleY,\n    messageFontSize: Math.max(96, 120 * Math.min(scaleX, scaleY)), // MUCH LARGER: 96-120pt\n    addressFontSize: Math.max(80, 96 * Math.min(scaleX, scaleY)),   // MUCH LARGER: 80-96pt\n  };\n} else {\n  // 6x9 layout - SIGNIFICANTLY LARGER FONTS \n  layout = {\n    messageLeft: 108 * scaleX,\n    messageTop: 108 * scaleY,\n    messageWidth: 1400 * scaleX, // Increased message area width\n    messageHeight: (base.height - 300) * scaleY, // Increased message area height\n    addressRight: 108 * scaleX,\n    addressBottom: 228 * scaleY,\n    addressWidth: 700 * scaleX,\n    addressHeight: 300 * scaleY,\n    messageFontSize: Math.max(120, 144 * Math.min(scaleX, scaleY)), // MUCH LARGER: 120-144pt\n    addressFontSize: Math.max(96, 112 * Math.min(scaleX, scaleY)),   // MUCH LARGER: 96-112pt\n  };\n}\n\n// Calculate address position\nconst addressX = dimensions.width - layout.addressRight - layout.addressWidth;\nconst addressY = dimensions.height - layout.addressBottom - layout.addressHeight;\n\nconsole.log(`[POSTCARD_BACK] Processing ${input.postcardSize} postcard: ${dimensions.width}x${dimensions.height}`);\nconsole.log(`[POSTCARD_BACK] Test Mode: ${isTestMode}`);\nconsole.log(`[POSTCARD_BACK] Message area: ${layout.messageWidth}x${layout.messageHeight} at (${layout.messageLeft}, ${layout.messageTop})`);\nconsole.log(`[POSTCARD_BACK] Address area: ${layout.addressWidth}x${layout.addressHeight} at (${addressX}, ${addressY})`);\nconsole.log(`[POSTCARD_BACK] LARGE Font sizes: message=${layout.messageFontSize}pt, address=${layout.addressFontSize}pt`);\n\nreturn [{\n  json: {\n    ...input,\n    dimensions,\n    layout: {\n      ...layout,\n      addressX,\n      addressY\n    },\n    isTestMode,\n    transactionId: input.transactionId || `postcard-${Date.now()}`\n  }\n}];"
      },
      "id": "validate-input",
      "name": "Validate Input & Calculate Layout",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -656,
        300
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "# Import required libraries\nfrom PIL import Image, ImageDraw, ImageFont\nimport io\nimport base64\nimport textwrap\nimport re\n\ndef generate_postcard_back():\n    try:\n        config = items[0]['json']\n        dimensions = config['dimensions']\n        layout = config['layout']\n        message = config['message']\n        recipient = config['recipientInfo']\n        postcard_size = config['postcardSize']\n        transaction_id = config['transactionId']\n        is_test_mode = config.get('isTestMode', False)\n        \n        print(f\"[POSTCARD_BACK] Creating {dimensions['width']}x{dimensions['height']} postcard back\")\n        print(f\"[POSTCARD_BACK] Transaction ID: {transaction_id}\")\n        print(f\"[POSTCARD_BACK] Test Mode: {is_test_mode}\")\n        print(f\"[POSTCARD_BACK] Message: {message[:50]}...\")\n        print(f\"[POSTCARD_BACK] LARGE Font sizes: message={layout['messageFontSize']}pt, address={layout['addressFontSize']}pt\")\n        \n        # Create white canvas\n        canvas = Image.new('RGB', (dimensions['width'], dimensions['height']), 'white')\n        draw = ImageDraw.Draw(canvas)\n        print(f\"[POSTCARD_BACK] Created white canvas: {canvas.size}\")\n        \n        # ENHANCED Font loading with better size handling\n        def load_font_with_size(size, bold=False):\n            size = int(size)\n            print(f\"[POSTCARD_BACK] Loading font with size {size}pt (bold: {bold})\")\n            \n            font_paths = [\n                # macOS fonts\n                f\"/System/Library/Fonts/Arial{'Bold' if bold else ''}.ttf\",\n                f\"/System/Library/Fonts/Helvetica{'Bold' if bold else ''}.ttc\",\n                # Linux fonts\n                f\"/usr/share/fonts/truetype/liberation/Liberation{'Bold' if bold else 'Sans'}-Regular.ttf\",\n                f\"/usr/share/fonts/truetype/dejavu/DejaVuSans{'Bold' if bold else ''}.ttf\",\n                # Windows fonts (if available)\n                f\"C:/Windows/Fonts/arial{'bd' if bold else ''}.ttf\"\n            ]\n            \n            for font_path in font_paths:\n                try:\n                    font = ImageFont.truetype(font_path, size)\n                    print(f\"[POSTCARD_BACK] SUCCESS: Loaded {font_path} at {size}pt\")\n                    return font\n                except (OSError, IOError) as e:\n                    print(f\"[POSTCARD_BACK] Failed to load {font_path}: {e}\")\n                    continue\n            \n            # Enhanced fallback that tries to respect size\n            print(f\"[POSTCARD_BACK] All TrueType fonts failed, trying fallback with size {size}\")\n            try:\n                # Try load_default with size parameter (newer Pillow versions)\n                fallback_font = ImageFont.load_default(size=size)\n                print(f\"[POSTCARD_BACK] SUCCESS: Using load_default with size {size}\")\n                return fallback_font\n            except Exception as e:\n                print(f\"[POSTCARD_BACK] load_default with size failed: {e}\")\n                try:\n                    # Try load_default_font with size parameter\n                    fallback_font = ImageFont.load_default_font(size=size)\n                    print(f\"[POSTCARD_BACK] SUCCESS: Using load_default_font with size {size}\")\n                    return fallback_font\n                except Exception as e2:\n                    print(f\"[POSTCARD_BACK] load_default_font failed: {e2}\")\n                    # Absolute last resort\n                    print(f\"[POSTCARD_BACK] WARNING: Using basic default font (size ignored)\")\n                    return ImageFont.load_default()\n        \n        # Load fonts with the calculated LARGE sizes\n        message_font_size = int(layout['messageFontSize'])\n        address_font_size = int(layout['addressFontSize'])\n        \n        message_font = load_font_with_size(message_font_size)\n        address_font = load_font_with_size(address_font_size)\n        address_font_bold = load_font_with_size(address_font_size, bold=True)\n        \n        print(f\"[POSTCARD_BACK] Fonts loaded successfully: message={message_font_size}pt, address={address_font_size}pt\")\n        \n        # Word wrap message text with better calculation for large fonts\n        # Estimate characters per line based on actual font size\n        avg_char_width = message_font_size * 0.55  # Slightly tighter for large fonts\n        max_chars_per_line = int(layout['messageWidth'] / avg_char_width)\n        \n        # Ensure reasonable line lengths for readability with large fonts\n        max_chars_per_line = max(12, min(max_chars_per_line, 50))  # Shorter lines for large fonts\n        \n        print(f\"[POSTCARD_BACK] Text wrapping: {max_chars_per_line} chars per line (font size {message_font_size}pt)\")\n        \n        # Wrap the text\n        wrapped_lines = textwrap.fill(message, width=max_chars_per_line).split('\\n')\n        \n        # Calculate line height with proper spacing for large fonts\n        line_height = message_font_size * 1.15  # Tight line spacing for large fonts\n        \n        # Draw message text line by line\n        current_y = layout['messageTop']\n        lines_drawn = 0\n        for i, line in enumerate(wrapped_lines):\n            if current_y + line_height > layout['messageTop'] + layout['messageHeight']:\n                print(f\"[POSTCARD_BACK] Message truncated at line {i} due to height limit\")\n                break\n            \n            draw.text(\n                (layout['messageLeft'], current_y),\n                line,\n                font=message_font,\n                fill='black'\n            )\n            current_y += line_height\n            lines_drawn += 1\n        \n        print(f\"[POSTCARD_BACK] Drew {lines_drawn} lines of message text with {message_font_size}pt font\")\n        \n        # Draw address section with proper spacing for large fonts\n        address_line_height = address_font_size * 1.1\n        current_y = layout['addressY']\n        \n        # Name (bold)\n        draw.text(\n            (layout['addressX'], current_y), \n            recipient['to'], \n            font=address_font_bold, \n            fill='black'\n        )\n        current_y += address_line_height\n        print(f\"[POSTCARD_BACK] Drew recipient name: {recipient['to']} with {address_font_size}pt bold font\")\n        \n        # Address line 1\n        draw.text(\n            (layout['addressX'], current_y), \n            recipient['addressLine1'], \n            font=address_font, \n            fill='black'\n        )\n        current_y += address_line_height\n        print(f\"[POSTCARD_BACK] Drew address line 1: {recipient['addressLine1']} with {address_font_size}pt font\")\n        \n        # Address line 2 (if exists)\n        if recipient.get('addressLine2') and recipient['addressLine2'].strip():\n            draw.text(\n                (layout['addressX'], current_y), \n                recipient['addressLine2'], \n                font=address_font, \n                fill='black'\n            )\n            current_y += address_line_height\n            print(f\"[POSTCARD_BACK] Drew address line 2: {recipient['addressLine2']} with {address_font_size}pt font\")\n        \n        # City, State ZIP (with small gap)\n        current_y += address_line_height * 0.15\n        city_state_zip = f\"{recipient['city']}, {recipient['state']} {recipient['zipcode']}\"\n        draw.text(\n            (layout['addressX'], current_y), \n            city_state_zip, \n            font=address_font, \n            fill='black'\n        )\n        print(f\"[POSTCARD_BACK] Drew city/state/zip: {city_state_zip} with {address_font_size}pt font\")\n        \n        # Convert to base64 PNG\n        buffer = io.BytesIO()\n        canvas.save(buffer, format='PNG', quality=100, optimize=True)\n        buffer.seek(0)\n        \n        img_base64 = base64.b64encode(buffer.getvalue()).decode('utf-8')\n        file_size = len(buffer.getvalue())\n        \n        print(f\"[POSTCARD_BACK] Generated postcard back: {file_size} bytes\")\n        print(f\"[POSTCARD_BACK] Canvas size: {canvas.size[0]}x{canvas.size[1]}\")\n        print(f\"[POSTCARD_BACK] FINAL Font sizes used: message={message_font_size}pt, address={address_font_size}pt\")\n        \n        return [{\n            'json': {\n                'success': True,\n                'postcardSize': postcard_size,\n                'dimensions': dimensions,\n                'transactionId': transaction_id,\n                'isTestMode': is_test_mode,\n                'fileSize': file_size,\n                'messageLines': lines_drawn,\n                'messageFontSize': message_font_size,\n                'addressFontSize': address_font_size\n            },\n            'binary': {\n                'postcard_back': {\n                    'data': img_base64,\n                    'mimeType': 'image/png',\n                    'fileName': f\"postcard-back-{transaction_id}.png\"\n                }\n            }\n        }]\n        \n    except Exception as e:\n        error_msg = str(e)\n        print(f\"[POSTCARD_BACK] Fatal error: {error_msg}\")\n        return [{\n            'json': {\n                'success': False,\n                'error': error_msg,\n                'postcardSize': config.get('postcardSize', 'unknown') if 'config' in locals() else 'unknown',\n                'transactionId': config.get('transactionId', 'unknown') if 'config' in locals() else 'unknown',\n                'isTestMode': config.get('isTestMode', False) if 'config' in locals() else False\n            }\n        }]\n\n# Execute the postcard back generation\nresult = generate_postcard_back()\nreturn result"
      },
      "id": "generate-postcard-back",
      "name": "Generate Postcard Back Image",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -448,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Convert binary to base64 for Cloudinary upload\nconst input = $input.all()[0];\nconst binaryData = input.binary.postcard_back;\n\nif (!binaryData) {\n  throw new Error('No binary data found');\n}\n\nconst base64String = `data:${binaryData.mimeType};base64,${binaryData.data}`;\n\nreturn [{\n  json: {\n    file_data: base64String,\n    upload_preset: 'xlpostcards-unsigned',\n    // Pass through metadata\n    originalData: input.json\n  }\n}];"
      },
      "id": "convert-binary",
      "name": "Convert Binary to Base64",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -240,
        300
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.cloudinary.com/v1_1/db9totnmb/image/upload",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "file",
              "value": "={{ $json.file_data }}"
            },
            {
              "name": "upload_preset",
              "value": "={{ $json.upload_preset }}"
            },
            {
              "name": "public_id",
              "value": "={{ $json.originalData.transactionId }}-postcard-back"
            },
            {
              "name": "folder",
              "value": "xlpostcards/backs"
            },
            {
              "name": "quality",
              "value": "100"
            },
            {
              "name": "format",
              "value": "png"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "id": "upload-cloudinary",
      "name": "Upload to Cloudinary",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        32,
        300
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"success\": true,\n  \"postcard_back_url\": \"{{ $json.secure_url }}\",\n  \"public_id\": \"{{ $json.public_id }}\",\n  \"postcardSize\": \"{{ $('Convert Binary to Base64').item.json.originalData.postcardSize }}\",\n  \"dimensions\": {\n    \"width\": {{ $('Convert Binary to Base64').item.json.originalData.dimensions.width }},\n    \"height\": {{ $('Convert Binary to Base64').item.json.originalData.dimensions.height }}\n  },\n  \"transactionId\": \"{{ $('Convert Binary to Base64').item.json.originalData.transactionId }}\",\n  \"isTestMode\": {{ $('Convert Binary to Base64').item.json.originalData.isTestMode }},\n  \"fileSize\": {{ $('Convert Binary to Base64').item.json.originalData.fileSize }},\n  \"messageLines\": {{ $('Convert Binary to Base64').item.json.originalData.messageLines }},\n  \"messageFontSize\": {{ $('Convert Binary to Base64').item.json.originalData.messageFontSize }},\n  \"addressFontSize\": {{ $('Convert Binary to Base64').item.json.originalData.addressFontSize }},\n  \"cloudinary_url\": \"{{ $json.url }}\",\n  \"generated_at\": \"{{ $now }}\"\n}",
        "options": {}
      },
      "id": "success-response",
      "name": "Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        320,
        300
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseCode": 400,
        "responseBody": "{\n  \"success\": false,\n  \"error\": \"{{ $json.error || 'Failed to generate postcard back' }}\",\n  \"postcardSize\": \"{{ $json.postcardSize || 'unknown' }}\",\n  \"transactionId\": \"{{ $json.transactionId || 'unknown' }}\",\n  \"isTestMode\": {{ $json.isTestMode || false }},\n  \"timestamp\": \"{{ $now }}\"\n}",
        "options": {}
      },
      "id": "error-response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        -240,
        480
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook - Unified Generate Postcard Back": {
      "main": [
        [
          {
            "node": "Validate Input & Calculate Layout",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input & Calculate Layout": {
      "main": [
        [
          {
            "node": "Generate Postcard Back Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Postcard Back Image": {
      "main": [
        [
          {
            "node": "Convert Binary to Base64",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert Binary to Base64": {
      "main": [
        [
          {
            "node": "Upload to Cloudinary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload to Cloudinary": {
      "main": [
        [
          {
            "node": "Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "your-instance-id"
  },
  "id": "xlpostcards-unified-postcard-workflow",
  "tags": [
    {
      "createdAt": "2024-01-01T00:00:00.000Z",
      "updatedAt": "2024-01-01T00:00:00.000Z",
      "id": "xlpostcards",
      "name": "XLPostcards"
    }
  ]
}