{
  "name": "XLPostcards - Unified Postcard Generator",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "generate-postcard-back-unified",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook - Generate Postcard Back",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        240,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Validate input and calculate layout\nconst input = $input.all()[0].json;\n\n// Validation\nif (!input.message || typeof input.message !== 'string') {\n  throw new Error('Message is required and must be a string');\n}\n\nif (!input.recipientInfo || !input.recipientInfo.to) {\n  throw new Error('Recipient information is required');\n}\n\nif (!input.postcardSize || !['regular', 'xl'].includes(input.postcardSize)) {\n  throw new Error('Invalid postcard size');\n}\n\n// Determine if this is a test mode request\nconst isTestMode = input.testMode === true || input.variant === 'development' || input.isTest === true;\n\n// Base dimensions for layout calculations (matching printSpecs.ts)\nconst baseDimensions = {\n  regular: { width: 1800, height: 1200 },\n  xl: { width: 2754, height: 1872 }\n};\n\nconst base = baseDimensions[input.postcardSize];\nconst dimensions = input.dimensions || base;\nconst scaleX = dimensions.width / base.width;\nconst scaleY = dimensions.height / base.height;\n\n// Layout calculations with MUCH LARGER fonts\nlet layout;\nif (input.postcardSize === 'regular') {\n  // 4x6 layout - significantly increased font sizes\n  layout = {\n    messageLeft: 72 * scaleX,\n    messageTop: 72 * scaleY,\n    messageWidth: 900 * scaleX,\n    messageHeight: (base.height - 144) * scaleY,\n    addressRight: 72 * scaleX,\n    addressBottom: 172 * scaleY,\n    addressWidth: 600 * scaleX,\n    addressHeight: 300 * scaleY,\n    messageFontSize: Math.max(120, 144 * Math.min(scaleX, scaleY)), // Much larger: 120-144pt\n    addressFontSize: Math.max(96, 112 * Math.min(scaleX, scaleY)),  // Much larger: 96-112pt\n  };\n} else {\n  // 6x9 layout - significantly increased font sizes\n  layout = {\n    messageLeft: 108 * scaleX,\n    messageTop: 108 * scaleY,\n    messageWidth: 1060 * scaleX,\n    messageHeight: (base.height - 216) * scaleY,\n    addressRight: 108 * scaleX,\n    addressBottom: 228 * scaleY,\n    addressWidth: 700 * scaleX,\n    addressHeight: 300 * scaleY,\n    messageFontSize: Math.max(144, 168 * Math.min(scaleX, scaleY)), // Much larger: 144-168pt\n    addressFontSize: Math.max(112, 128 * Math.min(scaleX, scaleY)), // Much larger: 112-128pt\n  };\n}\n\n// Calculate address position\nconst addressX = dimensions.width - layout.addressRight - layout.addressWidth;\nconst addressY = dimensions.height - layout.addressBottom - layout.addressHeight;\n\nconsole.log(`[POSTCARD_BACK] Processing ${input.postcardSize} postcard: ${dimensions.width}x${dimensions.height}`);\nconsole.log(`[POSTCARD_BACK] Test Mode: ${isTestMode}`);\nconsole.log(`[POSTCARD_BACK] Message area: ${layout.messageWidth}x${layout.messageHeight} at (${layout.messageLeft}, ${layout.messageTop})`);\nconsole.log(`[POSTCARD_BACK] Address area: ${layout.addressWidth}x${layout.addressHeight} at (${addressX}, ${addressY})`);\nconsole.log(`[POSTCARD_BACK] LARGE Font sizes: message=${layout.messageFontSize}pt, address=${layout.addressFontSize}pt`);\n\nreturn [{\n  json: {\n    ...input,\n    dimensions,\n    layout: {\n      ...layout,\n      addressX,\n      addressY\n    },\n    isTestMode,\n    transactionId: input.transactionId || `postcard-${Date.now()}`\n  }\n}];"
      },
      "id": "validate-input",
      "name": "Validate Input & Calculate Layout",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        300
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "# Import required libraries\nfrom PIL import Image, ImageDraw, ImageFont\nimport io\nimport base64\nimport textwrap\nimport re\n\ndef generate_postcard_back():\n    try:\n        config = items[0]['json']\n        dimensions = config['dimensions']\n        layout = config['layout']\n        message = config['message']\n        recipient = config['recipientInfo']\n        postcard_size = config['postcardSize']\n        transaction_id = config['transactionId']\n        is_test_mode = config.get('isTestMode', False)\n        \n        print(f\"[POSTCARD_BACK] Creating {dimensions['width']}x{dimensions['height']} postcard back\")\n        print(f\"[POSTCARD_BACK] Transaction ID: {transaction_id}\")\n        print(f\"[POSTCARD_BACK] Test Mode: {is_test_mode}\")\n        print(f\"[POSTCARD_BACK] Message: {message[:50]}...\")\n        print(f\"[POSTCARD_BACK] LARGE Font sizes: message={layout['messageFontSize']}pt, address={layout['addressFontSize']}pt\")\n        \n        # Create white canvas\n        canvas = Image.new('RGB', (dimensions['width'], dimensions['height']), 'white')\n        draw = ImageDraw.Draw(canvas)\n        print(f\"[POSTCARD_BACK] Created white canvas: {canvas.size}\")\n        \n        # FIXED: Font loading with better size handling\n        def load_font_with_size(size, bold=False):\n            size = int(size)\n            print(f\"[POSTCARD_BACK] Loading font with size {size}pt\")\n            \n            font_paths = [\n                # macOS fonts\n                f\"/System/Library/Fonts/Arial{'Bold' if bold else ''}.ttf\",\n                f\"/System/Library/Fonts/Helvetica{'Bold' if bold else ''}.ttc\",\n                # Linux fonts\n                f\"/usr/share/fonts/truetype/liberation/Liberation{'Bold' if bold else 'Sans'}-Regular.ttf\",\n                f\"/usr/share/fonts/truetype/dejavu/DejaVuSans{'Bold' if bold else ''}.ttf\",\n                # Windows fonts (if available)\n                f\"C:/Windows/Fonts/arial{'bd' if bold else ''}.ttf\"\n            ]\n            \n            for font_path in font_paths:\n                try:\n                    font = ImageFont.truetype(font_path, size)\n                    print(f\"[POSTCARD_BACK] Successfully loaded font: {font_path} at {size}pt\")\n                    return font\n                except (OSError, IOError) as e:\n                    print(f\"[POSTCARD_BACK] Failed to load {font_path}: {e}\")\n                    continue\n            \n            # Enhanced fallback that respects size\n            print(f\"[POSTCARD_BACK] All TrueType fonts failed, using fallback with size {size}\")\n            try:\n                # Try to get a default font that respects size\n                fallback_font = ImageFont.load_default(size)\n                print(f\"[POSTCARD_BACK] Using load_default with size {size}\")\n                return fallback_font\n            except Exception as e:\n                print(f\"[POSTCARD_BACK] load_default failed: {e}\")\n                # Absolute last resort\n                return ImageFont.load_default()\n        \n        # Load fonts with the calculated sizes\n        message_font_size = int(layout['messageFontSize'])\n        address_font_size = int(layout['addressFontSize'])\n        \n        message_font = load_font_with_size(message_font_size)\n        address_font = load_font_with_size(address_font_size)\n        address_font_bold = load_font_with_size(address_font_size, bold=True)\n        \n        print(f\"[POSTCARD_BACK] Fonts loaded: message={message_font_size}pt, address={address_font_size}pt\")\n        \n        # Word wrap message text with better calculation for large fonts\n        # Estimate characters per line based on actual font size\n        avg_char_width = message_font_size * 0.55  # Slightly tighter for large fonts\n        max_chars_per_line = int(layout['messageWidth'] / avg_char_width)\n        \n        # Ensure reasonable line lengths for readability\n        max_chars_per_line = max(15, min(max_chars_per_line, 60))\n        \n        print(f\"[POSTCARD_BACK] Text wrapping: {max_chars_per_line} chars per line (font size {message_font_size}pt)\")\n        \n        # Wrap the text\n        wrapped_lines = textwrap.fill(message, width=max_chars_per_line).split('\\n')\n        \n        # Calculate line height with proper spacing for large fonts\n        line_height = message_font_size * 1.2  # Slightly tighter line spacing\n        \n        # Draw message text line by line\n        current_y = layout['messageTop']\n        lines_drawn = 0\n        for i, line in enumerate(wrapped_lines):\n            if current_y + line_height > layout['messageTop'] + layout['messageHeight']:\n                print(f\"[POSTCARD_BACK] Message truncated at line {i} due to height limit\")\n                break\n            \n            draw.text(\n                (layout['messageLeft'], current_y),\n                line,\n                font=message_font,\n                fill='black'\n            )\n            current_y += line_height\n            lines_drawn += 1\n        \n        print(f\"[POSTCARD_BACK] Drew {lines_drawn} lines of message text with {message_font_size}pt font\")\n        \n        # Draw address section with proper spacing for large fonts\n        address_line_height = address_font_size * 1.15\n        current_y = layout['addressY']\n        \n        # Name (bold)\n        draw.text(\n            (layout['addressX'], current_y), \n            recipient['to'], \n            font=address_font_bold, \n            fill='black'\n        )\n        current_y += address_line_height\n        print(f\"[POSTCARD_BACK] Drew recipient name: {recipient['to']} with {address_font_size}pt bold font\")\n        \n        # Address line 1\n        draw.text(\n            (layout['addressX'], current_y), \n            recipient['addressLine1'], \n            font=address_font, \n            fill='black'\n        )\n        current_y += address_line_height\n        print(f\"[POSTCARD_BACK] Drew address line 1: {recipient['addressLine1']} with {address_font_size}pt font\")\n        \n        # Address line 2 (if exists)\n        if recipient.get('addressLine2') and recipient['addressLine2'].strip():\n            draw.text(\n                (layout['addressX'], current_y), \n                recipient['addressLine2'], \n                font=address_font, \n                fill='black'\n            )\n            current_y += address_line_height\n            print(f\"[POSTCARD_BACK] Drew address line 2: {recipient['addressLine2']} with {address_font_size}pt font\")\n        \n        # City, State ZIP (with small gap)\n        current_y += address_line_height * 0.2\n        city_state_zip = f\"{recipient['city']}, {recipient['state']} {recipient['zipcode']}\"\n        draw.text(\n            (layout['addressX'], current_y), \n            city_state_zip, \n            font=address_font, \n            fill='black'\n        )\n        print(f\"[POSTCARD_BACK] Drew city/state/zip: {city_state_zip} with {address_font_size}pt font\")\n        \n        # Convert to base64 PNG\n        buffer = io.BytesIO()\n        canvas.save(buffer, format='PNG', quality=100, optimize=True)\n        buffer.seek(0)\n        \n        img_base64 = base64.b64encode(buffer.getvalue()).decode('utf-8')\n        file_size = len(buffer.getvalue())\n        \n        print(f\"[POSTCARD_BACK] Generated postcard back: {file_size} bytes\")\n        print(f\"[POSTCARD_BACK] Canvas size: {canvas.size[0]}x{canvas.size[1]}\")\n        print(f\"[POSTCARD_BACK] Font sizes used: message={message_font_size}pt, address={address_font_size}pt\")\n        \n        return [{\n            'json': {\n                'success': True,\n                'postcardSize': postcard_size,\n                'dimensions': dimensions,\n                'transactionId': transaction_id,\n                'isTestMode': is_test_mode,\n                'fileSize': file_size,\n                'messageLines': lines_drawn,\n                'messageFontSize': message_font_size,\n                'addressFontSize': address_font_size\n            },\n            'binary': {\n                'postcard_back': {\n                    'data': img_base64,\n                    'mimeType': 'image/png',\n                    'fileName': f\"postcard-back-{transaction_id}.png\"\n                }\n            }\n        }]\n        \n    except Exception as e:\n        error_msg = str(e)\n        print(f\"[POSTCARD_BACK] Fatal error: {error_msg}\")\n        return [{\n            'json': {\n                'success': False,\n                'error': error_msg,\n                'postcardSize': config.get('postcardSize', 'unknown') if 'config' in locals() else 'unknown',\n                'transactionId': config.get('transactionId', 'unknown') if 'config' in locals() else 'unknown',\n                'isTestMode': config.get('isTestMode', False) if 'config' in locals() else False\n            }\n        }]\n\n# Execute the postcard back generation\nresult = generate_postcard_back()\nreturn result"
      },
      "id": "generate-postcard-back",
      "name": "Generate Postcard Back Image",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        680,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "success-condition",
              "leftValue": "={{ $json.success }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-success",
      "name": "Check Success",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        900,
        300
      ]
    },
    {
      "parameters": {
        "url": "https://api.cloudinary.com/v1_1/YOUR_CLOUD_NAME/image/upload",
        "sendBinaryData": true,
        "binaryPropertyName": "postcard_back",
        "options": {
          "bodyContentType": "multipart-form-data",
          "formData": {
            "parameters": [
              {
                "name": "public_id",
                "value": "={{ $json.transactionId }}-postcard-back"
              },
              {
                "name": "upload_preset",
                "value": "YOUR_UPLOAD_PRESET"
              },
              {
                "name": "folder",
                "value": "xlpostcards/backs"
              },
              {
                "name": "quality",
                "value": "100"
              },
              {
                "name": "format",
                "value": "png"
              }
            ]
          },
          "timeout": 30000
        }
      },
      "id": "upload-to-cloudinary",
      "name": "Upload to Cloudinary",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1120,
        200
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "test-mode-condition",
              "leftValue": "={{ $('Generate Postcard Back Image').item.json.isTestMode }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-test-mode",
      "name": "Check Test Mode",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1340,
        200
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"success\": true,\n  \"postcard_back_url\": \"{{ $('Upload to Cloudinary').item.json.secure_url }}\",\n  \"public_id\": \"{{ $('Upload to Cloudinary').item.json.public_id }}\",\n  \"postcardSize\": \"{{ $('Generate Postcard Back Image').item.json.postcardSize }}\",\n  \"dimensions\": {{ $('Generate Postcard Back Image').item.json.dimensions }},\n  \"transactionId\": \"{{ $('Generate Postcard Back Image').item.json.transactionId }}\",\n  \"isTestMode\": {{ $('Generate Postcard Back Image').item.json.isTestMode }},\n  \"fileSize\": {{ $('Generate Postcard Back Image').item.json.fileSize }},\n  \"messageLines\": {{ $('Generate Postcard Back Image').item.json.messageLines }},\n  \"messageFontSize\": {{ $('Generate Postcard Back Image').item.json.messageFontSize }},\n  \"addressFontSize\": {{ $('Generate Postcard Back Image').item.json.addressFontSize }},\n  \"cloudinary_url\": \"{{ $('Upload to Cloudinary').item.json.url }}\",\n  \"generated_at\": \"{{ $now }}\",\n  \"message\": \"TEST MODE - Postcard image generated but not sent to Stannp\"\n}",
        "options": {}
      },
      "id": "test-mode-response",
      "name": "Test Mode Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1560,
        120
      ]
    },
    {
      "parameters": {
        "url": "https://dash.stannp.com/api/v1/postcards/create",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"template\": false,\n  \"size\": \"{{ $('Generate Postcard Back Image').item.json.postcardSize }}\",\n  \"front\": \"{{ $('Generate Postcard Back Image').item.json.frontImageUrl || 'https://via.placeholder.com/600x400' }}\",\n  \"back\": \"{{ $('Upload to Cloudinary').item.json.secure_url }}\",\n  \"recipient\": {\n    \"title\": \"\",\n    \"firstname\": \"{{ $('Generate Postcard Back Image').item.json.recipientInfo.to.split(' ')[0] }}\",\n    \"lastname\": \"{{ $('Generate Postcard Back Image').item.json.recipientInfo.to.split(' ').slice(1).join(' ') }}\",\n    \"address1\": \"{{ $('Generate Postcard Back Image').item.json.recipientInfo.addressLine1 }}\",\n    \"address2\": \"{{ $('Generate Postcard Back Image').item.json.recipientInfo.addressLine2 || '' }}\",\n    \"city\": \"{{ $('Generate Postcard Back Image').item.json.recipientInfo.city }}\",\n    \"state\": \"{{ $('Generate Postcard Back Image').item.json.recipientInfo.state }}\",\n    \"postcode\": \"{{ $('Generate Postcard Back Image').item.json.recipientInfo.zipcode }}\",\n    \"country\": \"US\"\n  },\n  \"test\": false,\n  \"addons\": []\n}",
        "options": {}
      },
      "id": "send-to-stannp",
      "name": "Send to Stannp",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1560,
        280
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n  \"success\": true,\n  \"postcard_back_url\": \"{{ $('Upload to Cloudinary').item.json.secure_url }}\",\n  \"public_id\": \"{{ $('Upload to Cloudinary').item.json.public_id }}\",\n  \"postcardSize\": \"{{ $('Generate Postcard Back Image').item.json.postcardSize }}\",\n  \"dimensions\": {{ $('Generate Postcard Back Image').item.json.dimensions }},\n  \"transactionId\": \"{{ $('Generate Postcard Back Image').item.json.transactionId }}\",\n  \"isTestMode\": {{ $('Generate Postcard Back Image').item.json.isTestMode }},\n  \"fileSize\": {{ $('Generate Postcard Back Image').item.json.fileSize }},\n  \"messageLines\": {{ $('Generate Postcard Back Image').item.json.messageLines }},\n  \"messageFontSize\": {{ $('Generate Postcard Back Image').item.json.messageFontSize }},\n  \"addressFontSize\": {{ $('Generate Postcard Back Image').item.json.addressFontSize }},\n  \"cloudinary_url\": \"{{ $('Upload to Cloudinary').item.json.url }}\",\n  \"stannp_id\": \"{{ $json.data.id }}\",\n  \"stannp_status\": \"{{ $json.data.status }}\",\n  \"generated_at\": \"{{ $now }}\",\n  \"message\": \"PRODUCTION MODE - Postcard sent to Stannp for printing and mailing\"\n}",
        "options": {}
      },
      "id": "production-response",
      "name": "Production Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1780,
        280
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseCode": 400,
        "responseBody": "{\n  \"success\": false,\n  \"error\": \"{{ $json.error || 'Failed to generate postcard back' }}\",\n  \"postcardSize\": \"{{ $json.postcardSize || 'unknown' }}\",\n  \"transactionId\": \"{{ $json.transactionId || 'unknown' }}\",\n  \"isTestMode\": {{ $json.isTestMode || false }},\n  \"timestamp\": \"{{ $now }}\"\n}",
        "options": {}
      },
      "id": "error-response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1120,
        400
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook - Generate Postcard Back": {
      "main": [
        [
          {
            "node": "Validate Input & Calculate Layout",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input & Calculate Layout": {
      "main": [
        [
          {
            "node": "Generate Postcard Back Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Postcard Back Image": {
      "main": [
        [
          {
            "node": "Check Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Success": {
      "main": [
        [
          {
            "node": "Upload to Cloudinary",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload to Cloudinary": {
      "main": [
        [
          {
            "node": "Check Test Mode",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Test Mode": {
      "main": [
        [
          {
            "node": "Test Mode Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send to Stannp",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to Stannp": {
      "main": [
        [
          {
            "node": "Production Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "your-instance-id"
  },
  "id": "xlpostcards-unified-postcard-workflow",
  "tags": [
    {
      "createdAt": "2024-01-01T00:00:00.000Z",
      "updatedAt": "2024-01-01T00:00:00.000Z",
      "id": "xlpostcards",
      "name": "XLPostcards"
    }
  ]
}